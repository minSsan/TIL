# CORS (Cross-Origin-Resource-Sharing)

🗓 23.03.19

> 실제 배포하여 운영 중인 웹 서비스에서 갑자기 `CORS 에러`가 뜨면서, 백엔드 서버에서 프론트 서버의 요청을 계속 reject하는 문제가 발생했다.
>
> <img width="597" alt="image" src="https://user-images.githubusercontent.com/63039855/226174382-539a28b1-d7dd-44cc-b191-6bb3eb7a2ca6.png">
>
> 잘 동작하던 웹 서비스에서 해당 오류가 갑자기 발생한 상황이라, 이것저것 찾아보며 공부를 많이 해볼 수 있었다. _(결론적으로 CORS 설정 문제는 아니였다..)_
>
> 따라서 해당 오류를 해결하면서 `CORS`에 대해 학습한 내용을 기록하고자 한다.

<br>

# 🔒 CORS

CORS는 HTTP 요청에 **`Access-Control-Allow-Origin` 헤더**를 추가하여, <U>_다른 출처에서도 자원에 접근할 수 있도록_</U> 권한을 부여하는 방법이다.

가령, 하나의 웹 어플리케이션에서 **프론트 서버와 백엔드 서버를 따로 배포**하는 경우 즉, `서로 다른 출처(도메인, 프로토콜, 포트)`를 갖게 되는 경우 `CORS`를 사용해야 한다.

### 💌 출처(origin)?

> 클라이언트가 서버와 통신하기 위해서는 서버의 위치를 찾을 수 있어야 한다. 즉, **각 서버의 위치를 구분**할 수 있어야 한다. 이렇게 <U>_서버의 위치를 구분하는 것_</U>이 바로 출처이다.
>
> 이 출처를 구분하는 데 필요한 것으로는 `도메인`, `프로토콜`, `포트`가 있다. 셋 중 하나라도 다르면 서로 다른 출처로 취급된다.
>
> 참고로 https://www.naver.com 처럼 포트번호가 생략되는 경우에는 **디폴트 값**으로 포트번호가 설정된다. `http`와 `https`의 디폴트 포트번호는 각각 `80번`과 `443번`이다. _(-> 따라서 실제로는 `https://www.naver.com:443`)_

<br>

이런식으로 **브라우저**는 `Same-Origin Policy`에 따라 스크립트 파일(=클라이언트)의 HTTP 요청을 제한한다.  
가령 이 정책을 따르는 `Fetch API`, `XMLHttpRequest`를 이용하여 다른 출처의 리소스를 요청하는 경우, **요청을 받은 출처에서 응답 헤더에 CORS를 포함해야만** 리소스에 접근할 수 있다.

> ➕ 출처 비교는 서버에서 하는 것이 아니라, 브라우저가 진행한다.

<br>

# ✏️ CORS 동작 원리

이번에 문제가 발생했던 웹 서비스의 경우 `Preflight Request`를 활용하는 방식으로 동작했으며, 대부분의 웹 서비스가 해당 동작 방식을 따른다.

> ➕ 다른 동작 방식에 대해서는 아래에 첨부한 블로그 포스팅을 읽어보면 좋을 것 같다!

`preflight request`는 브라우저가 _실제 요청을 보내기 전_ 에 보내는 _**예비 요청**_ 이다. 즉, 브라우저가 해당 요청이 안전한지 확인하는 작업이다.

참고로 해당 요청은 `OPTIONS 메소드`를 사용한다.

<img width="514" alt="image" src="https://user-images.githubusercontent.com/63039855/226176653-5b667627-76e4-47a8-af7c-cb5ea3eeede0.png">

위 사진은 실제 문제가 발생했던 웹 서비스에서 preflight를 보낸 기록이다. `preflight` 헤더의 `origin`에는 **_요청을 보낸 측의 출처_** 가 담겨있다.(사진 참고)

브라우저는 preflight에 담은 `origin`(=리소스를 요청한 출처) 값과 서버 측에서 보낸 응답의 `Access-Control-Allow-Origin` 값을 비교하여 CORS 에러 여부를 판별한다.

> 이번에 문제가 발생한 웹 사이트에서는 preflight에 대한 응답 코드로 200을 반환하였다.  
> 나는 preflight에 대한 응답이 성공하면 CORS 오류가 나지 않을 줄 알았는데 해당 오류가 발생하였으며, 조사해보니 <U>_**`CORS 에러 여부`와 `preflight 요쳥 성공 여부`는 크게 상관이 없다**_</U>고 한다. 👉🏻 _브라우저가 CORS 에러를 판별하는 시점이 preflight에 대한 응답을 받은 이후이기 때문._

따라서 결국, **서버의 응답 헤더**의 `Access-Control-Allow-Origin` 값에 리소스를 요청한 **출처가 담겨있지 않으면**, CORS 에러가 발생하는 것이다.

<br>

# 🌟 문제 해결

이번에 에러가 발생했던 웹 서비스의 경우, 백엔드에서 해당 요청을 처리할 때 외부 API를 사용하고 있었다.

테스트로 postman을 이용하여 해당 API에 요청을 보냈을 때는 정상적으로 응답이 오는 반면, 웹 서비스 상에서는 CORS 에러가 발생하는 것을 보고 꽤나 당황했다.

혹시나 하여 파이썬 에디터에서 바로 해당 요청을 보내봤는데, 이 경우에도 에러가 발생하는 것을 확인할 수 있었다. 즉 _외부 API의 정책이 바뀌면서 응답이 제대로 오지 않았던 것_ 이다.

> 결론적으로는 `Request Header`에 `User-Agent`를 추가했더니 정상적으로 동작하였다. _추후 기회가 된다면 `User-Agent`에 대해서도 학습해보는게 좋을 것 같다._

<br>

### 참고 포스팅

✔️ [CORS 가 뭔데 CORS 에러 어떻게 해결하는건데](https://velog.io/@jh100m1/CORS-에러가-뭔데-어떻게-해결하는건데)

✔️ [MDN - CORS](https://developer.mozilla.org/ko/docs/Glossary/CORS)
