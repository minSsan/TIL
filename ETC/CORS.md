# CORS (Cross-Origin-Resource-Sharing)

🗓 23.03.19

> 실제 배포하여 운영 중인 웹 서비스에서 갑자기 `CORS 에러`가 뜨면서, 백엔드 서버에서 프론트 서버의 요청을 계속 reject하는 문제가 발생했다.
>
> <img width="597" alt="image" src="https://user-images.githubusercontent.com/63039855/226174382-539a28b1-d7dd-44cc-b191-6bb3eb7a2ca6.png">
>
> 잘 동작하던 웹 서비스에서 해당 오류가 갑자기 발생한 상황이라, 이것저것 찾아보며 공부를 많이 해볼 수 있었다. _(결론적으로 CORS 설정 문제는 아니였다..)_
>
> 따라서 해당 오류를 해결하면서 `CORS`에 대해 학습한 내용을 기록하고자 한다.

<br>

# 🔒 CORS

CORS는 HTTP 요청에 **`Access-Control-Allow-Origin` 헤더**를 추가하여, <U>_다른 출처에서도 자원에 접근할 수 있도록_</U> 권한을 부여하는 방법이다.

가령, 하나의 웹 어플리케이션에서 **프론트 서버와 백엔드 서버를 따로 배포**하는 경우 즉, `서로 다른 출처(도메인, 프로토콜, 포트)`를 갖게 되는 경우 `CORS`를 사용해야 한다.

### 💌 출처(origin)?

> 클라이언트가 서버와 통신하기 위해서는 서버의 위치를 찾을 수 있어야 한다. 즉, **각 서버의 위치를 구분**할 수 있어야 한다. 이렇게 <U>_서버의 위치를 구분하는 것_</U>이 바로 출처이다.
>
> 이 출처를 구분하는 데 필요한 것으로는 `도메인`, `프로토콜`, `포트`가 있다. 셋 중 하나라도 다르면 서로 다른 출처로 취급된다.
>
> 참고로 https://www.naver.com 처럼 포트번호가 생략되는 경우에는 **디폴트 값**으로 포트번호가 설정된다. `http`와 `https`의 디폴트 포트번호는 각각 `80번`과 `443번`이다. _(-> 따라서 실제로는 `https://www.naver.com:443`)_

<br>

이런식으로 **브라우저**는 `Same-Origin Policy`에 따라 스크립트 파일(=클라이언트)의 HTTP 요청을 제한한다.  
가령 이 정책을 따르는 `Fetch API`, `XMLHttpRequest`를 이용하여 다른 출처의 리소스를 요청하는 경우, **요청을 받은 출처에서 응답 헤더에 CORS를 포함해야만** 리소스에 접근할 수 있다.

> ➕ 출처 비교는 서버에서 하는 것이 아니라, 브라우저가 진행한다.

<br>

# ✏️ CORS 동작 원리

이번에 문제가 발생했던 웹 서비스의 경우 `Preflight Request`를 활용하는 방식으로 동작했으며, 대부분의 웹 서비스가 해당 동작 방식을 따른다.

> ➕ 다른 동작 방식에 대해서는 아래에 첨부한 블로그 포스팅을 읽어보면 좋을 것 같다!

`preflight request`는 브라우저가 _실제 요청을 보내기 전_ 에 보내는 _**예비 요청**_ 이다. 즉, 브라우저가 해당 요청이 안전한지 확인하는 작업이다.

참고로 해당 요청은 `OPTIONS 메소드`를 사용한다.

<img width="514" alt="image" src="https://user-images.githubusercontent.com/63039855/226176653-5b667627-76e4-47a8-af7c-cb5ea3eeede0.png">

위 사진은 실제 문제가 발생했던 웹 서비스에서 preflight를 보낸 기록이다. `preflight` 헤더의 `origin`에는 **_요청을 보낸 측의 출처_** 가 담겨있다.(사진 참고)

브라우저는 preflight에 담은 `origin`(=리소스를 요청한 출처) 값과 서버 측에서 보낸 응답의 `Access-Control-Allow-Origin` 값을 비교하여 CORS 에러 여부를 판별한다.

> 이번에 문제가 발생한 웹 사이트에서는 preflight에 대한 응답 코드로 200을 반환하였다.  
> 나는 preflight에 대한 응답이 성공하면 CORS 오류가 나지 않을 줄 알았는데 해당 오류가 발생하였으며, 조사해보니 <U>_**`CORS 에러 여부`와 `preflight 요쳥 성공 여부`는 크게 상관이 없다**_</U>고 한다. 👉🏻 _브라우저가 CORS 에러를 판별하는 시점이 preflight에 대한 응답을 받은 이후이기 때문._

따라서 결국, **서버의 응답 헤더**의 `Access-Control-Allow-Origin` 값에 리소스를 요청한 **출처가 담겨있지 않으면**, CORS 에러가 발생하는 것이다.

<br>

# 📖 정리

프로젝트에서 문제가 발생한 원인을 이해하기 위해, `CORS 에러 발생 경로`를 순서대로 작성하였다.

1. 예비 요청은 말 그대로 단순 "예비 요청"이기 때문에 서버에서도 별도의 오류 없이 **성공적으로 응답을 보내줌** _(아래 사진은 예비 요청에 대한 서버의 응답으로, 200 코드를 반환하였음)_  
   <img width="596" alt="image" src="https://user-images.githubusercontent.com/63039855/226833429-881bf4e0-4749-44e9-8a89-11f6efbe90a3.png">
2. 브라우저는 _예비 요청에 대한 서버의 응답 헤더_ 에 담긴 `Access-Controll-Allow-Origin` 값과, 클라이언트의 _예비 요청 헤더_ 에 담긴 `origin` **값을 비교**
3. 만약 두 값이 서로 같으면 브라우저는 _'아, 그러면 아까 클라이언트가 보냈던 본요청 서버에게 보내줘도 되겠다'_ 해서 _**서버에게 본 요청을 보냄**_
4. 본 요청 보냈더니 서버에서 **본 요청에 대한 응답을 제대로 안 줌.** _(이 프로젝트에서는 연결이 거부되면서 정상적으로 응답을 주지 않았음)_  
   따라서 응답 헤더에도 `Access-Controll-Allow-Origin`가 존재하지 않음.
5. 본 요청에 대한 응답으로 `Access-Controll-Allow-Origin` 값이 존재하지 않기 때문에 **CORS 에러 발생**

👉🏻 Preflight에 대한 검사가 정상정으로 이뤄지더라도, **_본 요청에 대한 응답이 정상적으로 수행되지 않으면_** CORS 에러가 발생할 수 있다. 특히 `Preflight의 성공 여부와 CORS 에러 발생 여부는 연관성이 없다.` **Preflight 응답을 받은 후에 출처를 비교**하기 때문이다.

<br>

### 참고 포스팅

✔️ [CORS 가 뭔데 CORS 에러 어떻게 해결하는건데](https://velog.io/@jh100m1/CORS-에러가-뭔데-어떻게-해결하는건데)

✔️ [MDN - CORS](https://developer.mozilla.org/ko/docs/Glossary/CORS)
