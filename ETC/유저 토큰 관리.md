# 유저 토큰 관리

🗓 22.12.08

> 프로젝트를 하나씩 진행하다보니, 유저의 접근 권한을 어떻게 관리하는지 궁금해졌다.  
> 지난번에 세션과 쿠키에 대해서 자료를 찾다보니, _`웹 스토리지`나 `쿠키`에 유저의 정보를 저장하지 않을까_ 라고 예측만 했었는데, 이번에 관련해서 포스팅을 찾아보게 되었다.  
> 그래서 **유저의 접근 권한 관리**에 대해 알게 된 내용들에 대해 기록하고자 한다.
>
> [👉🏻 참고 포스팅 - 자세한 설명과 Redux 소개](https://velog.io/@kim98111/Authentication)  
> [👉🏻 참고 포스팅 링크 - 이해하기 쉬운 동작과정과 개념 설명](https://hoime.tistory.com/94)

<br>

## ✏️ Authentication, Authorization

> 웹이나 앱 서비스를 이용할 때, 특정 리소스 열람에 대해서는 **로그인**이 필요한 상황이 생긴다. 로그인을 통해 **사용자의 정보**를 알아두고, **접근 권한**을 부여할 수도 있다.

<br>

### ✔️ **Authentication (인증)**

인증은 말 그대로 _**서비스에 등록되어있는 유저인지**_ `확인`하는 것이다. 즉, **로그인**을 생각할 수 있다.

### ✔️ **Authorization (인가)**

인증과 어감은 비슷하지만 의미는 다르게 사용된다. 인가는 _**유저가 특정 리소스에 대한 접근이 가능한지**_ 확인하는 것이다. `마이페이지 접근 권한` | `글 수정 및 삭제` 권한 등을 예로 들 수 있다.  
이렇게 특정 리소스에 대해서 사용자가 `접근`할 수 있는지, 그 **접근권한**을 확인하기 위해서 `토큰`을 사용한다.

<br>

## ✏️ 토큰은 서버가 클라이언트를 구분하기 위해 사용한다

> 클라이언트와 서버가 서로 통신할 때는 `HTTP 통신`을 한다. 하지만, HTTP 통신은 `stateless`하다는 특징을 가지고 있다. 즉, **하나의 요청 - 응답**이 발생될 때마다 **이전의 요청 - 응답**과 관계 없이 _**독립적**_ 으로 이루어지므로, <U>**서버는 클라이언트가 누구인지 특정할 수 있는 정보를 기억할 수 없다.**</U>

<br>

하지만 위에서 언급했듯이, 서버가 특정 사용자만이 접근하고 이용할 수 있는 리소스에 대해서 작업을 처리해야 하는 경우가 생긴다.

그런데 HTTP 통신의 stateless한 특징 때문에, `HTTP request` 정보만으로는 사용자를 특정하기 어렵다. 그리하여 등장한 것이 `토큰`이다. _(쿠키 | 세션을 활용하는 방법도 있지만, 서버가 각각의 유저에 대한 정보들을 저장해두어야 한다는 단점이 있다.)_

클라이언트가 토큰을 발급받으면, 이후에는 request를 보낼 때 **자신이 가지고 있는 토큰**을 함께 보내고, 서버는 이를 확인하여 `접근 권한`에 대한 작업을 처리할 수 있는 것이다.

<br>

## 🌟 프론트에서 토큰 관리하기

서버에 요청을 보낼 때, 헤더에 토큰을 담기 위해서 이전에 서버로부터 전달받은 토큰을 클라이언트가 관리해야 한다.

지난번에 `로컬 스토리지`에 대해 공부를 했었는데, 일단 로컬 스토리지란 _**브라우저에 데이터를 저장할 수 있는 공간**_ 이라고 배웠다. 또한 세션 스토리지와 달리, _세션이 종료되어도 데이터를 유지할 수 있다_ 는 특징이 있다.

따라서 토큰 또한 웹 스토리지를 이용하여 관리할 수도 있다. 그뿐만 아니라, `세션`이나 `쿠키`를 통해서도 브라우저에서 토큰을 관리할 수 있다.

그 전에, `액세스 토큰`과 `리프레시 토큰`에 대해서 짚고 넘어가고자 한다. 이는 _**토큰의 유효기간**_ 때문에 생겨난 것으로, 유효기간이 지날 때마다 토큰을 새로 갱신하기 위해 구분된 것이다.

<br>

### 👉🏻 **Token**

- **Access Token**  
  -> 서버에 요청을 보낼 때, reqeust 헤더에 담는 토큰이다.

- **Refresh Token**  
  -> 토큰 유효기간이 만료되면 기존에 가지고 있던 `Access Token` 은 소멸된다. 토큰은 한번 소멸되면 복구할 수 없기 때문에, 이를 대비하여 **2차적으로** 클라이언트를 검증하기 위해 `Refresh Token`이 사용한다.  
  따라서, 만약 헤더로 전달받은 클라이언트의 `Access Token`이 올바르지 않을 때, `Refresh Token`을 통해 **사용자를 또 한번 검증**하고, 이 검증을 통과하면 Access Token을 재발급 해준다.

<br>

### 👉🏻 **Token 저장 공간 생각하기**

> 앞에서 말했듯이, 브라우저에서 데이터를 저장하는 방법에는 여러가지가 있다. 우선 크게 `로컬 스토리지`에 저장하는 방법, `쿠키`로 저장하는 방법으로 나눌 수 있는데, 각 특징에 대해서 공부할 수 있었다.  
> [👉🏻 브라우저의 각 저장 공간과 보안 취약성](https://hoime.tistory.com/94)

<br>

- 1️⃣ Local Storage에 저장하기  
  우선 로컬 스토리지에 저장하는 방법이다. 자세한 설명은 위에 첨부한 포스팅을 통해 알아볼 수 있는데, 여기서는 간략하게 말하자면 **XSS 공격**에 취약하다고 한다.

- 2️⃣ 쿠키에 저장하기  
  참고로 쿠키 및 세션 동작 방식은 위에 첨부한 블로그의 다른 포스팅을 참고했다. [👉🏻 쿠키와 세션 동작 방식](https://hoime.tistory.com/93)  
  쿠키로 저장하는 방식은 기본적으로 HTTP 요청을 사용하게 되는데, 이 과정에서 **CSRF 공격**을 받을 수 있다. 또한, **XSS 공격**에도 취약하다고 한다.  
  관련 내용 또한 위에 첨부한 포스팅을 통해 더 자세히 알아볼 수 있다.

- 3️⃣ `secure`, `httpOnly` 쿠키  
  [👉🏻 secure, httpOnly cookie 관련 포스팅](https://nsinc.tistory.com/121)  
  위에서 언급한 보안적인 취약점을 해결할 수 있는 방안이다. 이는 서버에서 쿠키를 설정할 때 `secure`, `httpOnly` 옵션을 주어 쿠키에 옵션을 추가하는 방법이다.  
  특히 `httpOnly`을 통해 `javascript`를 통한 공격을 막을 수 있다.

<br>

따라서 **보안적인 측면**을 고려했을 때, `쿠키`에 옵션을 설정하여 브라우저에 `Access Token`과 `Refresh Token`을 저장하는 방법을 생각해볼 수 있겠다.

<br>

## ➕ React 에서 토큰 관리하기

[👉🏻 React + Redux로 토큰 관리 구현하기](https://velog.io/@kim98111/Authentication)  
리액트에서 토큰을 관리할 때는, 리액트 프로젝트에 존재하는 _**모든 페이지 및 컴포넌트에서**_ 토큰에 접근할 수 있도록, **상태관리 툴** (ex. `Redux`, `MobX` 등)을 활용할 수 있다.
