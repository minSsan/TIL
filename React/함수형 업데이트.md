# 함수형 업데이트

🗓 22.11.28

> 리액트의 `setState`는 **비동기적**으로 처리된다. 만약 동일한 state를 변경하는 setState를 여러번 호출하게 되면, 각각의 setState를 batch 처리 _(- 모든 setState를 한 곳에 모으고, 합치는 과정)_ 한다. [👉🏻 참고 포스팅](https://garve32.tistory.com/39)
>
> 이를 동기적으로 처리하기 위해서는 `함수형 업데이트`를 사용할 수 있다.

<br>

리액트에서 `setState`를 실행할 때 값을 바로 전달하는 방법도 있지만, prev 값을 인자로 받는 `함수형 업데이트`도 가능하다.

앞에서 언급했듯이 일반적인 방법으로는 setState를 실행할 때 `batching`이 발생하지만, `함수형 업데이트`를 사용하게 되면 각각의 setState가 `큐`에 순서대로 입력된다.

이렇게 `큐`에 입력되면, 각각의 setState가 수행될 때마다 값이 업데이트되고, _**(다만 큐에 저장된 작업이 모두 완료될 때까지는 렌더링이 발생하지 않는다.)**_ 그 다음 setState가 수행될 때 앞에서 _**수정된 값**_ 을 반영할 수 있는 것이다.

그리고 한 작업에서 setState가 **여러 번** 호출되더라도, 앞에서 언급한 `batching`, `큐` 작업으로 처리하기 때문에, <U>**단 한번의 렌더링**</U>만 발생한다.

<br>

## 💡 deps 값 대체하기

useCallback을 사용할 때, useCallback에 전달된 함수 내부에서 setState 실행하게 되면 해당 state 값이 변경될 때마다 함수를 재호출해주어야 한다.

따라서 원래대로라면 deps 배열에 state 값을 넣어주어야 한다.

```jsx
import { useState, useCallback } from "react";

const [active, setActive] = useState();

const handleClick = useCallback(() => {
  setActive(!active);
}, [active]);
```

> 프로젝트를 진행하다가 `useCallback`을 사용하게 되었는데, `useCallback`에 담긴 함수 내부에서 **state 값**을 사용하였다.  
> 따라서 useCallback의 `deps` 로 해당 state 값을 넘겨주었는데, 이렇게 되면 _**deps 값이 업데이트 될 때마다 함수를 재호출**_ 하게 된다.
