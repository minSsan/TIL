# JVM (Java Virtual Machine)

> `시스템 메모리`를 관리하며, `이식 가능한` 자바 프로그램 환경을 제공한다.  
> 👉🏻 `JAVA`와 `OS` 사이의 중개자 역할로, **운영체제에 상관없이 코드를 재사용 가능하게** 한다.

### Keywords

- JVM 실행 과정
- 가비지 컬렉션

### 등장 배경

> 기존에는 같은 코드라고 하더라도 운영체제 및 기기마다 컴파일 결과가 서로 달랐다. 즉, 서로 다른 운영체제에서는 같은 파일을 실행할 수 없었다.

1. 운영체제 및 기기가 서로 다르더라도 코드가 문제 없이 실행될 수 있도록 등장했다.
2. 프로그램의 메모리 관리를 최적화 하기 위해 등장했다.

### JVM 실행과정 및 메모리 관리

![JVM 실행 과정](https://camo.githubusercontent.com/8da41ebfa5ffb921bd442b0410c7cd4ab8ee7686f9d37eb0696c7e2822c0e1e4/68747470733a2f2f692e696d6775722e636f6d2f5679314a4331622e706e67)

- **자바 컴파일러**  
  자바 소스 코드(.java)를 자바 바이트 코드(.class)로 변환한다.

- **클래스 로더**  
  런타임시 JVM이 처음으로 클래스를 참조할 때, 클래스 로더가 **해당 클래스를 로드하고 메모리 영역에 배치**한다.

- **Runtime Data Areas**

  > `Method Area`와 `Heap`은 **스레드간 공유**되는 영역

  JVM이 운영체제에서 실행되기 위해 할당받은 메모리 영역

  - **PC Register** - JVM의 명령어 주소를 가리키는 역할
  - **JVM Stack** - `지역변수`, `매개변수`, `메서드 정보`, `임시 데이터` 등 저장
  - **Native Method Stack** - 기계어로 작성된 프로그램을 실행시키는 영역
  - **Heap** - 런타임에 동적으로 할당(`배열`, `객체` 생성시)되는 데이터가 저장되는 영역  
    ⭐️ **힙 영역에 있는 데이터는 가비지 컬렉터의 대상** (JVM 성능 이슈에서 가장 많이 언급) ⭐️
  - **Method Area** - **JVM이 시작될 때 생성**. JVM이 읽은 각 클래스와 인터페이스에 대한 런타임 상수 풀, 필드 및 메서드 코드, 정적 변수, 메서드와 바이트 코드 등을 보관하는 영역

#### 실행과정

1. 프로그램이 실행되면 JVM은 OS로부터 프로그램 실행에 필요한 메모리를 할당받는다.
   - JVM은 이 영역을 용도에 따라 분리하여 관리
2. 자바 컴파일러(JAVAC)가 소스코드(.java)를 바이트 코드(.class)로 변환한다.
3. 변환된 바이트 코드는 JVM의 클래스 로더를 통해, JVM의 메모리 영역으로 로드된다.
4. `Excecution Engine`이 로드된 바이트 코드를 해석한다.
5. 해석된 바이트 코드가 메모리 영역에 올라가면서 실행된다.
   - 이때 JVM은 리소스 관리 작업(스레드 동기화, 가비지 컬렉션 등)을 수행

#### 가비지 컬렉션 (Garbage Collection)

> 자바에서는 JVM이 가비지 컬렉션이라는 프로세스를 통해 프로그램 메모리를 관리함. _(자바 이전에는 프로그래머가 직접 메모리를 관리)_
>
> `객체`는 실제로 `Heap 영역`에 생성되며, **Method Area** 및 **Stack Area**에서는 객체가 위치한 Heap 영역의 주소를 참조한다.

👉🏻 사용되지 않는 메모리를 찾아서 삭제하는 역할

- **실행 순서**  
  `참조되지 않은 객체` 탐색 및 삭제 -> 삭제 된 객체의 메모리 반환 -> 반환된 메모리 재사용

- **Stop The World**  
  GC가 실행되는 동안, GC 관련 스레드를 제외한 나머지 프로그램의 실행이 중단되는 것
